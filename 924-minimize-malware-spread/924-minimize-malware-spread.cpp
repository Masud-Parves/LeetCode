class Union_Find {
public:
    Union_Find(int sz) : rank(sz), root(sz){
        for(int i=0; i<sz; i++){
            rank[i] = 1;
            root[i] = i;
        }
    }
    
    int Find(int x){
        if(x == root[x]) return x;
        return root[x] = Find(root[x]);
    }
    
    void Union(int x, int y){
        int rootX = Find(x);
        int rootY = Find(y);
        if(rootX == rootY) return;
        if(rootX>rootY) swap(rootX, rootY);
        
        root[rootY] = rootX;
        rank[rootX] += rank[rootY];
    }
    int getNodeSize(int x){
        return rank[x];
    }
private:
    vector<int> root;
    vector<int> rank;
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        Union_Find dsu(n);
        
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                if(graph[i][j] == 1){
                    dsu.Union(i, j);
                }
            }
        }
        int maxSize = 0, maxNode = -1;
        vector<int> rootInfectedMemberCount(n, 0);
        
        for(auto& node : initial){
            int rootNode = dsu.Find(node);
            rootInfectedMemberCount[rootNode]++;
        }
        
        for(auto& node : initial){
            int rootNode = dsu.Find(node);
            if(rootInfectedMemberCount[rootNode] == 1){
                int currNodeSize = dsu.getNodeSize(rootNode);
                if(maxSize<dsu.getNodeSize(rootNode)){
                    maxSize = currNodeSize;
                    maxNode = node;
                } else if(maxSize == currNodeSize){
                    maxNode = min(maxNode, node);
                }
            }
        }
        
        if(maxNode == -1){
            maxNode = INT_MAX;
            for(auto& node : initial){
                maxNode = min(maxNode, node);
            }
        }
        
        return maxNode;
    }
};